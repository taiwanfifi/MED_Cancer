#!/usr/bin/env python3
"""
Experiment 20: Epigenetic Vulnerability Mapping
================================================
Maps cancer-type-specific dependencies on epigenetic regulators using
DepMap CRISPR data, identifies druggable epigenetic vulnerabilities,
and correlates with gene expression and mutations.

Hypothesis: Different cancer types have distinct epigenetic dependencies.
Cancers with mutations in one epigenetic complex (e.g., SWI/SNF) become
dependent on compensatory complexes (e.g., PRC2), creating targetable
vulnerabilities.

Key analyses:
1. Pan-cancer epigenetic dependency landscape (DepMap)
2. Cancer-type-specific essential epigenetic regulators
3. Mutation-driven epigenetic rewiring (SWI/SNF → PRC2 switching)
4. Expression-dependency correlation
5. Druggable epigenetic targets per cancer type

Target: Paper on epigenetic vulnerability in cancer
"""

import json
import logging
from pathlib import Path

import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats

BASE_DIR = Path("/workspace/cancer_research")
DATA_DIR = BASE_DIR / "data"
RESULTS_DIR = BASE_DIR / "results" / "exp20_epigenetic"
RESULTS_DIR.mkdir(parents=True, exist_ok=True)

logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

# Epigenetic gene families
EPIGENETIC_GENES = {
    'SWI_SNF': {
        'genes': ['SMARCA4', 'SMARCA2', 'SMARCB1', 'ARID1A', 'ARID1B', 'ARID2',
                  'PBRM1', 'DPF2', 'BRD7', 'BRD9', 'SMARCC1', 'SMARCC2',
                  'SMARCD1', 'SMARCE1', 'ACTL6A', 'BCL7A'],
        'description': 'SWI/SNF chromatin remodeling complex',
        'drugs': {'SMARCA2': 'FHD-286 (clinical trial)', 'BRD9': 'BI-7273 (preclinical)'},
    },
    'PRC2': {
        'genes': ['EZH2', 'EZH1', 'SUZ12', 'EED', 'RBBP4', 'RBBP7', 'JARID2', 'AEBP2'],
        'description': 'Polycomb Repressive Complex 2 (H3K27me3)',
        'drugs': {'EZH2': 'Tazemetostat (FDA approved)'},
    },
    'PRC1': {
        'genes': ['RING1', 'RNF2', 'BMI1', 'CBX2', 'CBX4', 'CBX6', 'CBX7', 'CBX8',
                  'PCGF1', 'PCGF2', 'PCGF3', 'PCGF5', 'PCGF6'],
        'description': 'Polycomb Repressive Complex 1 (H2A ubiquitination)',
        'drugs': {},
    },
    'HDAC': {
        'genes': ['HDAC1', 'HDAC2', 'HDAC3', 'HDAC4', 'HDAC5', 'HDAC6',
                  'HDAC7', 'HDAC8', 'HDAC9', 'HDAC10', 'HDAC11', 'SIRT1', 'SIRT2'],
        'description': 'Histone deacetylases',
        'drugs': {'HDAC1': 'Vorinostat/Romidepsin (FDA)', 'HDAC6': 'Ricolinostat'},
    },
    'HAT': {
        'genes': ['KAT2A', 'KAT2B', 'CREBBP', 'EP300', 'KAT6A', 'KAT6B', 'KAT7', 'KAT8'],
        'description': 'Histone acetyltransferases',
        'drugs': {'CREBBP': 'A-485 (preclinical)', 'EP300': 'CCS1477 (clinical trial)'},
    },
    'DNMT': {
        'genes': ['DNMT1', 'DNMT3A', 'DNMT3B', 'TET1', 'TET2', 'TET3'],
        'description': 'DNA methyltransferases and demethylases',
        'drugs': {'DNMT1': 'Azacitidine/Decitabine (FDA)', 'DNMT3A': 'Azacitidine'},
    },
    'KMT': {
        'genes': ['KMT2A', 'KMT2B', 'KMT2C', 'KMT2D', 'SETD1A', 'SETD1B',
                  'SETD2', 'NSD1', 'NSD2', 'NSD3', 'DOT1L', 'EHMT1', 'EHMT2'],
        'description': 'Histone lysine methyltransferases',
        'drugs': {'DOT1L': 'Pinometostat (clinical trial)', 'EHMT2': 'UNC0642 (preclinical)'},
    },
    'KDM': {
        'genes': ['KDM1A', 'KDM2A', 'KDM2B', 'KDM3A', 'KDM4A', 'KDM4B', 'KDM4C',
                  'KDM5A', 'KDM5B', 'KDM5C', 'KDM6A', 'KDM6B'],
        'description': 'Histone lysine demethylases',
        'drugs': {'KDM1A': 'Iadademstat (clinical trial)', 'KDM5B': 'KDOAM-25 (preclinical)'},
    },
    'BET': {
        'genes': ['BRD2', 'BRD3', 'BRD4', 'BRDT'],
        'description': 'Bromodomain and Extra-Terminal family',
        'drugs': {'BRD4': 'JQ1/OTX015/ABBV-075 (clinical trials)'},
    },
}


def load_gene_effect():
    """Load DepMap CRISPR gene effect data."""
    ge_file = DATA_DIR / "drug_repurpose" / "depmap_gene_effect.parquet"
    if not ge_file.exists():
        logger.error("DepMap gene effect not found")
        return pd.DataFrame()
    ge = pd.read_parquet(ge_file)
    ge.columns = [c.split(' (')[0] if ' (' in str(c) else c for c in ge.columns]
    logger.info(f"DepMap: {ge.shape[0]} cell lines x {ge.shape[1]} genes")
    return ge


def load_cell_line_info():
    """Load cell line metadata."""
    cli_file = DATA_DIR / "drug_repurpose" / "depmap_cell_line_info.parquet"
    if not cli_file.exists():
        return pd.DataFrame()
    return pd.read_parquet(cli_file)


def pan_cancer_epigenetic_landscape(gene_effect):
    """
    Map overall essentiality of epigenetic regulators across all cell lines.
    """
    all_epi_genes = []
    for family, info in EPIGENETIC_GENES.items():
        for gene in info['genes']:
            if gene in gene_effect.columns:
                effect = gene_effect[gene]
                all_epi_genes.append({
                    'gene': gene,
                    'family': family,
                    'mean_effect': float(effect.mean()),
                    'median_effect': float(effect.median()),
                    'essential_fraction': float((effect < -0.5).mean()),
                    'strongly_essential': float((effect < -1.0).mean()),
                    'std_effect': float(effect.std()),
                    'n_cell_lines': int(effect.notna().sum()),
                })

    landscape = pd.DataFrame(all_epi_genes)
    landscape = landscape.sort_values('mean_effect')
    logger.info(f"Pan-cancer landscape: {len(landscape)} epigenetic genes")
    return landscape


def cancer_specific_dependencies(gene_effect, cell_line_info):
    """
    Identify cancer-type-specific epigenetic dependencies.
    Compare essentiality in each cancer type vs. all others.
    """
    if 'lineage' in cell_line_info.columns:
        lineage_col = 'lineage'
    elif 'primary_disease' in cell_line_info.columns:
        lineage_col = 'primary_disease'
    else:
        lineage_col = cell_line_info.columns[1]

    lineages = cell_line_info[lineage_col].value_counts()
    top_lineages = lineages[lineages >= 10].index.tolist()
    logger.info(f"Analyzing {len(top_lineages)} lineages with >=10 cell lines")

    all_results = []
    for lineage in top_lineages:
        lineage_lines = cell_line_info[cell_line_info[lineage_col] == lineage].index
        lineage_lines = lineage_lines.intersection(gene_effect.index)
        other_lines = gene_effect.index.difference(lineage_lines)

        if len(lineage_lines) < 5:
            continue

        for family, info in EPIGENETIC_GENES.items():
            for gene in info['genes']:
                if gene not in gene_effect.columns:
                    continue

                eff_lineage = gene_effect.loc[lineage_lines, gene].dropna()
                eff_other = gene_effect.loc[other_lines, gene].dropna()

                if len(eff_lineage) < 5 or len(eff_other) < 20:
                    continue

                t_stat, p_val = stats.ttest_ind(eff_lineage, eff_other)
                pooled_std = np.sqrt((eff_lineage.std()**2 + eff_other.std()**2) / 2)
                cohens_d = (eff_lineage.mean() - eff_other.mean()) / (pooled_std + 1e-8)

                all_results.append({
                    'lineage': lineage,
                    'gene': gene,
                    'family': family,
                    'mean_effect_lineage': float(eff_lineage.mean()),
                    'mean_effect_other': float(eff_other.mean()),
                    'delta': float(eff_lineage.mean() - eff_other.mean()),
                    'cohens_d': float(cohens_d),
                    't_stat': float(t_stat),
                    'p_value': float(p_val),
                    'essential_in_lineage': float((eff_lineage < -0.5).mean()),
                    'essential_in_other': float((eff_other < -0.5).mean()),
                    'n_lineage': len(eff_lineage),
                    'n_other': len(eff_other),
                })

    results_df = pd.DataFrame(all_results)
    if not results_df.empty:
        results_df['fdr'] = stats.false_discovery_control(results_df['p_value'])
        results_df = results_df.sort_values('p_value')

    logger.info(f"Cancer-specific tests: {len(results_df)}")
    if not results_df.empty:
        sig = results_df[results_df['fdr'] < 0.05]
        logger.info(f"Significant (FDR<0.05): {len(sig)}")
    return results_df


def mutation_epigenetic_rewiring(gene_effect, cell_line_info):
    """
    Test the SWI/SNF → PRC2 switching hypothesis:
    Cell lines with SWI/SNF mutations become more dependent on PRC2.
    """
    swi_snf_genes = EPIGENETIC_GENES['SWI_SNF']['genes']
    prc2_genes = EPIGENETIC_GENES['PRC2']['genes']

    results = []

    # For each SWI/SNF gene, test if its loss increases PRC2 dependency
    for swi_gene in swi_snf_genes:
        if swi_gene not in gene_effect.columns:
            continue

        # Define SWI/SNF dependent vs not
        effect = gene_effect[swi_gene].dropna()
        dep_threshold = effect.quantile(0.25)  # Bottom 25% = most dependent
        dep_lines = effect[effect < dep_threshold].index
        nodep_lines = effect[effect >= dep_threshold].index

        for prc2_gene in prc2_genes:
            if prc2_gene not in gene_effect.columns:
                continue

            prc2_dep = gene_effect[prc2_gene].dropna()
            common_dep = dep_lines.intersection(prc2_dep.index)
            common_nodep = nodep_lines.intersection(prc2_dep.index)

            if len(common_dep) < 10 or len(common_nodep) < 10:
                continue

            prc2_in_dep = prc2_dep.loc[common_dep]
            prc2_in_nodep = prc2_dep.loc[common_nodep]

            t_stat, p_val = stats.ttest_ind(prc2_in_dep, prc2_in_nodep)

            results.append({
                'swi_snf_gene': swi_gene,
                'prc2_gene': prc2_gene,
                'mean_prc2_swi_dep': float(prc2_in_dep.mean()),
                'mean_prc2_swi_nodep': float(prc2_in_nodep.mean()),
                'delta': float(prc2_in_dep.mean() - prc2_in_nodep.mean()),
                't_stat': float(t_stat),
                'p_value': float(p_val),
                'n_dep': len(common_dep),
                'n_nodep': len(common_nodep),
            })

    rewiring_df = pd.DataFrame(results)
    if not rewiring_df.empty:
        rewiring_df['fdr'] = stats.false_discovery_control(rewiring_df['p_value'])
        rewiring_df = rewiring_df.sort_values('p_value')

    logger.info(f"Rewiring tests: {len(rewiring_df)}")
    if not rewiring_df.empty:
        sig = rewiring_df[rewiring_df['fdr'] < 0.05]
        logger.info(f"  Significant (FDR<0.05): {len(sig)}")
        if not sig.empty:
            logger.info(f"  Top hits:\n{sig.head(5).to_string()}")
    return rewiring_df


def expression_dependency_correlation(gene_effect, cancer_types=None):
    """
    Correlate TCGA expression with DepMap dependency for epigenetic genes.
    Tests: do cancers that overexpress an epigenetic gene also depend on it?
    """
    if cancer_types is None:
        cancer_types = ['BRCA', 'LUAD', 'KIRC']

    results = []
    for cancer in cancer_types:
        expr_file = DATA_DIR / "tcga_expression" / f"{cancer}_expression_matrix.parquet"
        if not expr_file.exists():
            expr_file = DATA_DIR / "tcga" / f"{cancer}_expression.parquet"
        if not expr_file.exists():
            continue

        expr = pd.read_parquet(expr_file)
        gene_index_map = {g.upper(): g for g in expr.index}

        for family, info in EPIGENETIC_GENES.items():
            for gene in info['genes']:
                idx = gene_index_map.get(gene.upper())
                if idx is None or gene not in gene_effect.columns:
                    continue

                # TCGA median expression
                tcga_median = float(expr.loc[idx].astype(float).median())

                # DepMap mean essentiality
                depmap_mean = float(gene_effect[gene].mean())
                depmap_essential_frac = float((gene_effect[gene] < -0.5).mean())

                results.append({
                    'gene': gene,
                    'family': family,
                    'cancer_type': cancer,
                    'tcga_median_expr': tcga_median,
                    'depmap_mean_effect': depmap_mean,
                    'depmap_essential_frac': depmap_essential_frac,
                })

    corr_df = pd.DataFrame(results)
    return corr_df


def identify_druggable_vulnerabilities(landscape, cancer_specific, rewiring):
    """
    Prioritize druggable epigenetic targets.
    """
    druggable = []
    all_drugs = {}
    for family, info in EPIGENETIC_GENES.items():
        for gene, drug in info.get('drugs', {}).items():
            all_drugs[gene] = drug

    for gene, drug in all_drugs.items():
        # Get pan-cancer essentiality
        pan = landscape[landscape['gene'] == gene]
        if pan.empty:
            continue

        entry = {
            'gene': gene,
            'drug': drug,
            'family': pan.iloc[0]['family'],
            'pan_cancer_mean_effect': float(pan.iloc[0]['mean_effect']),
            'pan_cancer_essential_frac': float(pan.iloc[0]['essential_fraction']),
        }

        # Get cancer-specific info
        if not cancer_specific.empty:
            gene_specific = cancer_specific[
                (cancer_specific['gene'] == gene) & (cancer_specific['fdr'] < 0.05)
            ]
            if not gene_specific.empty:
                most_dep = gene_specific.nsmallest(1, 'delta')
                entry['most_dependent_lineage'] = most_dep.iloc[0]['lineage']
                entry['lineage_delta'] = float(most_dep.iloc[0]['delta'])
            else:
                entry['most_dependent_lineage'] = 'None significant'
                entry['lineage_delta'] = 0

        # Check rewiring
        if not rewiring.empty:
            gene_rewire = rewiring[
                (rewiring['prc2_gene'] == gene) & (rewiring['fdr'] < 0.05)
            ]
            entry['rewiring_partners'] = len(gene_rewire)

        druggable.append(entry)

    druggable_df = pd.DataFrame(druggable)
    if not druggable_df.empty:
        druggable_df = druggable_df.sort_values('pan_cancer_essential_frac', ascending=False)
    return druggable_df


def plot_results(landscape, cancer_specific, rewiring, druggable, expr_dep, output_dir):
    """Generate comprehensive figures."""
    fig = plt.figure(figsize=(22, 18))

    # 1. Pan-cancer epigenetic dependency landscape
    ax1 = fig.add_subplot(2, 3, 1)
    if not landscape.empty:
        family_colors = {
            'SWI_SNF': '#e41a1c', 'PRC2': '#377eb8', 'PRC1': '#4daf4a',
            'HDAC': '#984ea3', 'HAT': '#ff7f00', 'DNMT': '#a65628',
            'KMT': '#f781bf', 'KDM': '#999999', 'BET': '#66c2a5',
        }
        for family in landscape['family'].unique():
            mask = landscape['family'] == family
            data = landscape[mask]
            ax1.scatter(data['mean_effect'], data['essential_fraction'],
                       c=family_colors.get(family, 'gray'), label=family,
                       s=40, alpha=0.7)
            # Label essential genes
            for _, row in data[data['essential_fraction'] > 0.3].iterrows():
                ax1.annotate(row['gene'], (row['mean_effect'], row['essential_fraction']),
                           fontsize=6, ha='center')
        ax1.set_xlabel('Mean Gene Effect')
        ax1.set_ylabel('Fraction Cell Lines Essential')
        ax1.set_title('Pan-Cancer Epigenetic Dependencies')
        ax1.legend(fontsize=6, ncol=2)
        ax1.axhline(0.5, color='gray', linestyle='--', alpha=0.3)
        ax1.axvline(-0.5, color='gray', linestyle='--', alpha=0.3)

    # 2. Cancer-specific heatmap (top dependencies)
    ax2 = fig.add_subplot(2, 3, 2)
    if not cancer_specific.empty:
        sig = cancer_specific[cancer_specific['fdr'] < 0.05]
        if len(sig) > 0:
            # Get top genes per lineage
            top_genes = sig.nsmallest(30, 'delta')[['gene', 'lineage', 'delta']]
            pivot = top_genes.pivot_table(index='gene', columns='lineage',
                                          values='delta', aggfunc='first')
            if len(pivot) > 0:
                pivot = pivot.iloc[:15]  # Top 15
                sns.heatmap(pivot, cmap='RdBu_r', center=0, ax=ax2,
                           annot=True, fmt='.2f', cbar_kws={'label': 'Delta Effect'},
                           xticklabels=True, yticklabels=True)
                ax2.set_title('Cancer-Specific Dependencies\n(FDR<0.05)')
                ax2.tick_params(axis='x', rotation=45)
                ax2.tick_params(axis='y', labelsize=8)

    # 3. SWI/SNF → PRC2 rewiring
    ax3 = fig.add_subplot(2, 3, 3)
    if not rewiring.empty:
        sig_rew = rewiring[rewiring['fdr'] < 0.05]
        if len(sig_rew) > 0:
            pivot = sig_rew.pivot_table(index='swi_snf_gene', columns='prc2_gene',
                                        values='delta', aggfunc='first')
            if len(pivot) > 0:
                sns.heatmap(pivot, cmap='RdBu_r', center=0, ax=ax3,
                           annot=True, fmt='.2f',
                           cbar_kws={'label': 'PRC2 Effect Change'})
                ax3.set_title('SWI/SNF → PRC2 Rewiring\n(Significant Pairs)')
        else:
            ax3.text(0.5, 0.5, 'No significant\nrewiring detected',
                    ha='center', va='center', transform=ax3.transAxes)
            ax3.set_title('SWI/SNF → PRC2 Rewiring')
    else:
        ax3.text(0.5, 0.5, 'No rewiring data', ha='center', va='center',
                transform=ax3.transAxes)

    # 4. Family-level essentiality
    ax4 = fig.add_subplot(2, 3, 4)
    if not landscape.empty:
        family_ess = landscape.groupby('family').agg({
            'essential_fraction': 'mean',
            'mean_effect': 'mean',
            'gene': 'count',
        }).rename(columns={'gene': 'n_genes'}).sort_values('essential_fraction', ascending=True)
        colors = [family_colors.get(f, 'gray') for f in family_ess.index]
        ax4.barh(range(len(family_ess)), family_ess['essential_fraction'], color=colors)
        ax4.set_yticks(range(len(family_ess)))
        ax4.set_yticklabels([f"{f} (n={int(n)})" for f, n in
                            zip(family_ess.index, family_ess['n_genes'])])
        ax4.set_xlabel('Mean Essential Fraction')
        ax4.set_title('Epigenetic Family Essentiality')

    # 5. Druggable targets
    ax5 = fig.add_subplot(2, 3, 5)
    if not druggable.empty:
        drug_plot = druggable.head(12)
        colors_drug = ['#e41a1c' if e > 0.3 else '#377eb8' if e > 0.1 else '#999999'
                      for e in drug_plot['pan_cancer_essential_frac']]
        ax5.barh(range(len(drug_plot)),
                drug_plot['pan_cancer_essential_frac'],
                color=colors_drug)
        ax5.set_yticks(range(len(drug_plot)))
        labels = [f"{row['gene']}\n({row['drug'][:25]})"
                 for _, row in drug_plot.iterrows()]
        ax5.set_yticklabels(labels, fontsize=7)
        ax5.set_xlabel('Essential Fraction (pan-cancer)')
        ax5.set_title('Druggable Epigenetic Targets')
        ax5.invert_yaxis()

    # 6. Expression vs dependency
    ax6 = fig.add_subplot(2, 3, 6)
    if not expr_dep.empty:
        for cancer in expr_dep['cancer_type'].unique():
            subset = expr_dep[expr_dep['cancer_type'] == cancer]
            ax6.scatter(subset['tcga_median_expr'], subset['depmap_mean_effect'],
                       alpha=0.5, s=30, label=cancer)
            # Annotate most essential
            most_ess = subset.nsmallest(3, 'depmap_mean_effect')
            for _, row in most_ess.iterrows():
                ax6.annotate(row['gene'],
                           (row['tcga_median_expr'], row['depmap_mean_effect']),
                           fontsize=6)
        ax6.set_xlabel('TCGA Median Expression')
        ax6.set_ylabel('DepMap Mean Effect')
        ax6.set_title('Expression vs Dependency')
        ax6.legend(fontsize=8)
        ax6.axhline(-0.5, color='gray', linestyle='--', alpha=0.3)

    plt.suptitle('Experiment 20: Epigenetic Vulnerability Mapping',
                fontsize=16, fontweight='bold')
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.savefig(output_dir / 'epigenetic_landscape.png', dpi=150, bbox_inches='tight')
    plt.close()
    logger.info("Saved epigenetic_landscape.png")


def main():
    logger.info("=" * 60)
    logger.info("Experiment 20: Epigenetic Vulnerability Mapping")
    logger.info("=" * 60)

    # Load data
    gene_effect = load_gene_effect()
    if gene_effect.empty:
        logger.error("No DepMap data. Cannot proceed.")
        return

    cell_line_info = load_cell_line_info()

    # Step 1: Pan-cancer landscape
    logger.info("\n--- Step 1: Pan-Cancer Epigenetic Landscape ---")
    landscape = pan_cancer_epigenetic_landscape(gene_effect)
    logger.info(f"Most essential epigenetic genes:")
    logger.info(landscape.head(10).to_string())

    # Step 2: Cancer-specific dependencies
    logger.info("\n--- Step 2: Cancer-Specific Dependencies ---")
    cancer_specific = pd.DataFrame()
    if not cell_line_info.empty:
        cancer_specific = cancer_specific_dependencies(gene_effect, cell_line_info)

    # Step 3: SWI/SNF → PRC2 rewiring
    logger.info("\n--- Step 3: Mutation-Driven Epigenetic Rewiring ---")
    rewiring = mutation_epigenetic_rewiring(gene_effect, cell_line_info)

    # Step 4: Expression-dependency correlation
    logger.info("\n--- Step 4: Expression-Dependency Correlation ---")
    expr_dep = expression_dependency_correlation(gene_effect)

    # Step 5: Druggable vulnerabilities
    logger.info("\n--- Step 5: Druggable Epigenetic Targets ---")
    druggable = identify_druggable_vulnerabilities(landscape, cancer_specific, rewiring)
    if not druggable.empty:
        logger.info(f"Top druggable targets:")
        logger.info(druggable.to_string())

    # Save results
    logger.info("\n--- Saving Results ---")
    landscape.to_csv(RESULTS_DIR / 'epigenetic_landscape.csv', index=False)
    if not cancer_specific.empty:
        cancer_specific.to_csv(RESULTS_DIR / 'cancer_specific_dependencies.csv', index=False)
    if not rewiring.empty:
        rewiring.to_csv(RESULTS_DIR / 'swi_snf_prc2_rewiring.csv', index=False)
    if not expr_dep.empty:
        expr_dep.to_csv(RESULTS_DIR / 'expression_dependency.csv', index=False)
    if not druggable.empty:
        druggable.to_csv(RESULTS_DIR / 'druggable_epigenetic_targets.csv', index=False)

    # Plot
    plot_results(landscape, cancer_specific, rewiring, druggable, expr_dep, RESULTS_DIR)

    # Summary
    n_families = len(set(landscape['family'])) if not landscape.empty else 0
    top_essential = landscape.nlargest(5, 'essential_fraction')[
        ['gene', 'family', 'mean_effect', 'essential_fraction']
    ].to_dict('records') if not landscape.empty else []

    summary = {
        'experiment': 'Exp 20: Epigenetic Vulnerability Mapping',
        'epigenetic_families': n_families,
        'total_genes_tested': len(landscape),
        'pan_cancer_landscape': {
            'most_essential': top_essential,
        },
        'cancer_specific': {
            'total_tests': len(cancer_specific),
            'significant_fdr05': int((cancer_specific['fdr'] < 0.05).sum()) if not cancer_specific.empty else 0,
            'lineages_tested': int(cancer_specific['lineage'].nunique()) if not cancer_specific.empty else 0,
        },
        'rewiring': {
            'total_tests': len(rewiring),
            'significant_fdr05': int((rewiring['fdr'] < 0.05).sum()) if not rewiring.empty else 0,
        },
        'druggable_targets': druggable[['gene', 'drug', 'pan_cancer_essential_frac']].to_dict('records') if not druggable.empty else [],
    }
    with open(RESULTS_DIR / 'exp20_summary.json', 'w') as f:
        json.dump(summary, f, indent=2, default=str)

    logger.info(f"\nExp 20 COMPLETE")
    logger.info(f"Epigenetic genes tested: {len(landscape)}")
    logger.info(f"Families: {n_families}")
    if not cancer_specific.empty:
        logger.info(f"Cancer-specific significant: {(cancer_specific['fdr'] < 0.05).sum()}")
    if not rewiring.empty:
        logger.info(f"Rewiring significant: {(rewiring['fdr'] < 0.05).sum()}")
    logger.info(f"Results saved to {RESULTS_DIR}")


if __name__ == '__main__':
    main()
